/****************************************************************/
/* MOOSE - Multiphysics Object Oriented Simulation Environment  */
/*                                                              */
/*          All contents are licensed under LGPL V2.1           */
/*             See LICENSE for full restrictions                */
/****************************************************************/

#include "ComputeCrackFrictionHeatEnergyDienes3D.h"
#include <math.h> 

registerMooseObject("pandaApp",ComputeCrackFrictionHeatEnergyDienes3D);
template <>
InputParameters
validParams<ComputeCrackFrictionHeatEnergyDienes3D>()
{
  InputParameters params = validParams<Material>();
  params.addParam<std::string>("base_name",
                               "Optional parameter that allows the user to define "
                               "multiple mechanics material systems on the same "
                               "block, i.e. for multiple phases");
  params.addClassDescription("Heat energy density generated by crack friction, according to Dienes 2006");
  params.addRequiredCoupledVar("c","Damage");
  params.addRequiredCoupledVar("dcdx","First derivative of damage with respect to x");
  params.addRequiredCoupledVar("dcdy","First derivative of damage with respect to y");
  params.addRequiredCoupledVar("dcdz","First derivative of damage with respect to z");
  params.addRequiredParam<Real>("friction_coefficient","crack friction coefficient");
  params.addRequiredParam<Real>("l", "Interface width");
  return params;
}

ComputeCrackFrictionHeatEnergyDienes3D::ComputeCrackFrictionHeatEnergyDienes3D(const InputParameters & parameters)
  : DerivativeMaterialInterface<Material>(parameters),
    _base_name(isParamValid("base_name") ? getParam<std::string>("base_name") + "_" : ""),
    _c(coupledValue("c")),
    _dcdx(coupledValue("dcdx")),
    _dcdy(coupledValue("dcdy")),
    _dcdz(coupledValue("dcdz")),
    _crack_normal(declareProperty<std::vector<Real>>("crack_normal")), // Normal to the crack surface
    _crack_normal_norm(declareProperty<Real>("crack_normal_norm")),
    _stress(getMaterialPropertyByName<RankTwoTensor>("stress")),
    _strain_rate(getMaterialPropertyByName<RankTwoTensor>("strain_rate")),
    _Jacobian_mult(getMaterialProperty<RankFourTensor>("Jacobian_mult")),
    _deformation_gradient(getMaterialProperty<RankTwoTensor>("deformation_gradient")),
    _deformation_gradient_old(getMaterialPropertyOld<RankTwoTensor>("deformation_gradient")),
    _friction_coefficient(getParam<Real>("friction_coefficient")),
    _l(getParam<Real>("l")),
    _friction_force(declareProperty<std::vector<Real>>("friction_force")),
    _friction_normal_force(declareProperty<Real>("friction_normal_force")),
    _slide_velocity(declareProperty<std::vector<Real>>("slide_velocity")),
    _slide_velocity_parallel(declareProperty<Real>("slide_velocity_parallel")),
    _crack_surface_density(declareProperty<Real>("crack_surface_density")),
    _heat_source_rate(declareProperty<Real>("heat_source_rate")),
    _velocity_gradient(declareProperty<RankTwoTensor>("velocity_gradient"))
{
}

//crossProduct(vector<double>& a,vector<double>& b)
//{
//  vector<double> _crossProduct;
//  Real _crossProduct_norm= 0.0;
// _crossProduct[0]=a[1]*b[2]-a[2]*b[1];
//  _crossProduct[1]=a[2]*b[0]-a[0]*b[2];
//  _crossProduct[2]=a[0]*b[1]-a[1]*b[0];
//  _crossProduct_norm = std::sqrt(_crossProduct[_qp][0]*_crossProduct[_qp][0]+_crossProduct[_qp][1]*_crossProduct[_qp][1]+_crossProduct[_qp][2]*_crossProduct[_qp][2])
//  return _crossProduct_norm;
//}
   
void
ComputeCrackFrictionHeatEnergyDienes3D::computeQpProperties()
{

  unsigned int i, j;
  Real slide_velocity_dot_crack_normal = 0.0;

  _crack_normal_norm[_qp] = std::sqrt( _dcdx[_qp]*_dcdx[_qp] + _dcdy[_qp]*_dcdy[_qp] + _dcdz[_qp]*_dcdz[_qp] );

  _crack_surface_density[_qp] = 0.5*_c[_qp]*_c[_qp] + 0.5*_l*_l*_crack_normal_norm[_qp]*_crack_normal_norm[_qp];

  _crack_normal[_qp].resize(3);

  if ( _crack_normal_norm[_qp] > 1.0e-9 ) {
    _crack_normal[_qp][0] = - _dcdx[_qp] / _crack_normal_norm[_qp];
    _crack_normal[_qp][1] = - _dcdy[_qp] / _crack_normal_norm[_qp];
    _crack_normal[_qp][2] = - _dcdz[_qp] / _crack_normal_norm[_qp];
  }
  else {
    _crack_normal[_qp][0] = 0.0;
    _crack_normal[_qp][1] = 0.0;
    _crack_normal[_qp][2] = 0.0;
  }

  _velocity_gradient[_qp] = ( _deformation_gradient[_qp] - _deformation_gradient_old[_qp] ) / _dt;

  _friction_force[_qp].resize(3);
  _slide_velocity[_qp].resize(3);

  for( int i = 0; i < 3; i = i + 1 ) {
    _friction_force[_qp][i] = 0.0;
    _slide_velocity[_qp][i] = 0.0;
  }

  for( int i = 0; i < 3; i = i + 1 ) {
    for( int j = 0; j < 3; j = j + 1 ) {
      _friction_force[_qp][i] += _stress[_qp](i, j) * _crack_normal[_qp][j];
      _slide_velocity[_qp][i] += _velocity_gradient[_qp](i, j) * _crack_normal[_qp][j];
    }
  }

  _friction_normal_force[_qp] = 0.0;
  for( int i = 0; i < 3; i = i + 1 ) {
    _friction_normal_force[_qp] += _friction_force[_qp][i] * _crack_normal[_qp][i];
  }

  for( int i = 0; i < 3; i = i + 1 ) {
    slide_velocity_dot_crack_normal += _slide_velocity[_qp][i] * _crack_normal[_qp][i];
  }
  //_slide_velocity_parallel[_qp]= std::crossProduct(_crack_normal[_qp],_slide_velocity[_qp]);
  _slide_velocity_parallel[_qp] = std::sqrt(
				pow((_crack_normal[_qp][1]*_slide_velocity[_qp][2]-_crack_normal[_qp][2]*_slide_velocity[_qp][1]),2)
				+pow((_crack_normal[_qp][0]*_slide_velocity[_qp][2]-_crack_normal[_qp][2]*_slide_velocity[_qp][0]),2)
				+pow((_crack_normal[_qp][0]*_slide_velocity[_qp][1]-_crack_normal[_qp][1]*_slide_velocity[_qp][0]),2));

  _heat_source_rate[_qp] = 0.0;

  if ( _friction_normal_force[_qp] < 0.0 ) { // slide_velocity_dot_crack_normal < 0.0 condition for crack closing rate
    _heat_source_rate[_qp] = - _friction_coefficient * _friction_normal_force[_qp] * _slide_velocity_parallel[_qp];
    _heat_source_rate[_qp] *= _crack_surface_density[_qp];
  }

}
